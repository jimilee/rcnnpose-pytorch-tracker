Index: examples/tracker_demo.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport cv2\r\nimport torch\r\nimport torchvision\r\nimport random, math, time, sys\r\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler\r\nfrom scipy.optimize import linear_sum_assignment\r\nfrom torchvision import transforms\r\nfrom PIL import Image\r\nfrom simsiam_standalone import simsiam_model\r\n\r\nclass simple_tracker():\r\n    def __init__(self):\r\n        self.simsiam = simsiam_model()\r\n        self.trackers = {}\r\n        self.init_id_tracker()\r\n        self.last_id, self.max_tracker=0,5\r\n        self.minmax_scaler = MinMaxScaler()\r\n        self.stand_scaler = StandardScaler()\r\n\r\n    def init_id_tracker(self):\r\n        for i in range(0, 5):\r\n            color = []\r\n            for c in range(3): color.append(random.randrange(0, 256))\r\n            self.trackers[i] = {'id': i, 'stat': False, 'feat': 0, 'frame': 0, 'hist': 0, 'rgb': color}\r\n\r\n    def cal_histogram(self,img):\r\n        return cv2.calcHist([img],[0],None,[256],[0,256])\r\n\r\n    def cos_sim(self, A, B):\r\n        return np.dot(A,B)/(np.linalg.norm(A)*np.linalg.norm(B))\r\n\r\n    def euclid_sim(self, A, B):\r\n        return np.sqrt(np.sum((A-B)**2))\r\n\r\n    def dist_sim(self, A, B):\r\n        Ax1, Ay1, Ax2, Ay2 = A\r\n        Bx1, By1, Bx2, By2 = B\r\n        Acx = Ax1 + ((Ax2-Ax1) / 2)\r\n        Acy = Ay1 + ((Ay2 - Ay1) / 2)\r\n        Bcx = Bx1 + ((Bx2-Bx1) / 2)\r\n        Bcy = By1 + ((By2 - By1) / 2)\r\n        point_com_sxy = [min(Ax1, Bx1), min(Ay1, By1)]\r\n        point_com_bxy = [max(Ax2, Bx2), max(Ay2, By2)]\r\n        point_ovl_sxy = [max(Ax1, Bx1), max(Ay1, By1)]\r\n        point_ovl_bxy = [min(Ax2, Bx2), min(Ay2, By2)]\r\n\r\n        a_center_pt = [Acx, Acy]\r\n        b_center_pt = [Bcx, Bcy]\r\n\r\n        comb_area = (point_com_bxy[0] - point_com_sxy[0]) * (point_com_bxy[1] - point_com_sxy[1])\r\n        ovl_area = max(point_ovl_bxy[0] - point_ovl_sxy[0], 0) * max(point_ovl_bxy[1] - point_ovl_sxy[1], 0)\r\n        ovl_score = ovl_area / comb_area\r\n        result = float((\r\n                               (1 - math.sqrt(math.pow(a_center_pt[0] - b_center_pt[0], 2) + math.pow(a_center_pt[1] - b_center_pt[1], 2)))\r\n                               + ovl_score)/2)\r\n        return result\r\n\r\n    def bbox_sim_score(self, target):\r\n        dist, euclid, hist, ovl = [], [], [], []\r\n        target_trk = [state for id, state in self.trackers.items() if state['stat'] is True]\r\n        len_trk = len(target_trk)\r\n        dist_score = np.ones(shape=(len_trk,), dtype=np.float32)\r\n        euclid_score = np.ones(shape=(len_trk,), dtype=np.float32)\r\n\r\n        for j, trk in enumerate(target_trk):\r\n            # print(target)\r\n            dist.append(self.dist_sim(target['box'], trk['box']))\r\n            euclid.append(self.euclid_sim(target['hist'], trk['hist']))\r\n\r\n        if (len(dist) > 0):\r\n            dist = np.array(dist).reshape(len(dist), 1)\r\n            euclid = np.array(euclid).reshape(len(dist), 1)\r\n            self.minmax_scaler.fit(dist)\r\n            self.stand_scaler.fit(euclid)\r\n            result = self.minmax_scaler.transform(dist)\r\n            eu_result = self.stand_scaler.transform(euclid)\r\n\r\n        for j, trk in enumerate(target_trk):\r\n            dist_score[j] = result[j]\r\n            euclid_score[j] = 1 - eu_result[j]\r\n        return dist_score, euclid_score\r\n\r\n\r\n    # 트래커 초기화 및 업데이트.\r\n    # target_ : 업데이트 시킬 타겟,\r\n    # num_trk : id 할당 우선순위용.\r\n    # t_id, update : 트래커 업데이트 시, 사용.\r\n    def tracker_provider(self, target_, t_id=None, update=False):\r\n        print(self.last_id, self.max_tracker)\r\n        if self.last_id >= self.max_tracker - 1:\r\n            self.last_id = 0\r\n\r\n        if update and t_id is not None:\r\n            rgb = self.trackers[t_id]['rgb']\r\n            if not self.occluded_tracker(target_):\r\n                tracker_feat = target_['feat']\r\n                tracker_hist = target_['hist']\r\n\r\n            else:\r\n                tracker_feat = self.trackers[t_id]['feat']\r\n                tracker_hist = self.trackers[t_id]['hist']\r\n\r\n            self.trackers[t_id] = {'id': t_id, 'frame': target_['frame'], 'stat': True,\r\n                                   'box': target_['box'],\r\n                                   'hist': tracker_hist,\r\n                                   'feat': tracker_feat,\r\n                                   'rgb': rgb}\r\n\r\n        # if d_id != -1:\r\n        #     self.id_table[d_id]['stat'] = False\r\n        elif self.last_id < self.max_tracker:\r\n            for id, state in self.trackers.items():\r\n                rgb = self.trackers[id]['rgb']\r\n                if self.trackers[id]['stat'] is False and id >= self.last_id:\r\n                    self.last_id = id\r\n\r\n                    self.trackers[id] = {'id': id, 'frame': target_['frame'], 'stat': True,\r\n                                         'box': target_['box'],\r\n                                         'hist': target_['hist'],\r\n                                         'feat': target_['feat'],\r\n                                         'rgb': rgb}  # id 할당되면 true.\r\n\r\n                    # print(id, '트래커 할당.', self.trackers[id])\r\n                    return int(id)\r\n\r\n    def occluded_tracker(self, target, ovl_th = 0.5):\r\n        # print(target)\r\n        target_sx, target_bx, target_sy, target_by = target['box']\r\n\r\n        for idx, tracker in self.trackers.items():\r\n            if self.trackers[idx]['stat'] is True: # and self.id_table[idx]['frame'] == cur_frame\r\n                Bx1, By1, Bx2, By2 = self.trackers[idx]['box']\r\n                point_ovl_sxy = [max(target_sx, Bx1), max(target_sy, By1)]\r\n                point_ovl_bxy = [min(target_bx, Bx2), min(target_by, By2)]\r\n\r\n                target_area = (target_bx - target_sx) * (target_by - target_sy)\r\n                ovl_area = max(point_ovl_bxy[0] - point_ovl_sxy[0], 0) * max(point_ovl_bxy[1] - point_ovl_sxy[1], 0)\r\n                ovl_score = ovl_area / target_area\r\n\r\n                if ovl_score > ovl_th and target_by-target_sy < (By2 - By1):\r\n                    return True\r\n    #트래커 제거자.\r\n    def tracker_eliminator(self, cur_frame):\r\n        age_TH = 3\r\n        for idx, tracker in self.trackers.items():\r\n            if self.trackers[idx]['stat'] is True:\r\n                # if self.occluded_tracker(idx):\r\n                #     age_TH = 15\r\n                if int(cur_frame - tracker['frame']) > age_TH:\r\n                    # del self.id_table[idx]\r\n                    print('트래커 삭제', self.trackers[idx]['id'], cur_frame - tracker['frame'])\r\n                    self.trackers[idx]['stat'] = False\r\n\r\n    def convert_img_tensor(self, src):\r\n        color_cvt = cv2.cvtColor(src, cv2.COLOR_BGR2RGB)\r\n        pil_src = Image.fromarray(color_cvt)\r\n        trans = transforms.Compose([transforms.Resize((224,112)),\r\n                                  transforms.ToTensor()])\r\n        trans_target = trans(pil_src)\r\n        # print(trans_target.shape)\r\n        return trans_target\r\n\r\n    def simsiam_sim_score(self, target):\r\n        target_trk = [state['feat'].unsqueeze(0) for id, state in self.trackers.items() if state['stat'] is True]\r\n        len_trk = len(target_trk)\r\n        # dist_score = np.ones(shape=(len_trk,), dtype=np.float32)\r\n        # euclid_score = np.ones(shape=(len_trk,), dtype=np.float32)\r\n        if(len_trk > 0):\r\n            trackers = torch.cat(target_trk, dim=0)\r\n            ass_mat = self.simsiam.get_association_matrix(self.simsiam.backbone, trackers, target.unsqueeze(0), k=min(len_trk, 5))\r\n            print(ass_mat)\r\n        # for j, trk in enumerate(target_trk):\r\n        #     # print(target)\r\n        #\r\n        #     sim.append(self.dist_sim(target['box'], trk['box']))\r\n        #     euclid.append(self.euclid_sim(target['feat'], trk['feat']))\r\n        #\r\n        # if (len(dist) > 0):\r\n        #     dist = np.array(dist).reshape(len(dist), 1)\r\n        #     euclid = np.array(euclid).reshape(len(dist), 1)\r\n        #     self.minmax_scaler.fit(dist)\r\n        #     self.stand_scaler.fit(euclid)\r\n        #     result = self.minmax_scaler.transform(dist)\r\n        #     eu_result = self.stand_scaler.transform(euclid)\r\n        #\r\n        # for j, trk in enumerate(target_trk):\r\n        #     dist_score[j] = result[j]\r\n        #     euclid_score[j] = 1 - eu_result[j]\r\n        # return dist_score, euclid_score\r\n\r\n    def tracking(self, det_boxes, image, frame_cnt):\r\n        target_det = []\r\n        src = image.copy()\r\n        matrix_size = len(det_boxes) if len(self.trackers) < len(det_boxes) else len(self.trackers)\r\n        score_matrix = np.full((matrix_size + 1, matrix_size + 1), 1.0, dtype=float)\r\n        for i, det in enumerate(det_boxes):\r\n            x1, y1 = det[:2]\r\n            x2, y2 = det[2:]\r\n\r\n            if (x2-x1) < 8 or (y2-y1) < 8:\r\n                continue\r\n            # feat = src.crop((max(x1, 0), max(y1, 0), min(x2, src.size[0]), min(y2, src.size[1])))\r\n            feat = src[y1:y2, x1:x2]\r\n            roi_hsv = cv2.cvtColor(feat, cv2.COLOR_BGR2HSV)\r\n            tensor_src = self.convert_img_tensor(feat)\r\n\r\n            sim_score = self.simsiam_sim_score(tensor_src)\r\n\r\n            # HS 히스토그램 계산\r\n            channels = [0, 1]\r\n            ranges = [0, 180, 0, 256]\r\n            det_hist = cv2.calcHist([roi_hsv], channels, None, [90, 128], ranges)\r\n\r\n            # print(len(det_boxes))\r\n            det_data = {'id': -1,\r\n                        'frame': frame_cnt,\r\n                        'box': det,\r\n                        'hist': det_hist,\r\n                        'feat': tensor_src}\r\n\r\n            if frame_cnt == 0:\r\n                det_data['id'] = self.tracker_provider(det_data)  # 트래커 생성\r\n                continue\r\n\r\n\r\n            dist_score, euclid_score = self.bbox_sim_score(det_data)\r\n\r\n\r\n            for j, trk in self.trackers.items():\r\n                if self.trackers[j]['stat']:\r\n                    try:\r\n                        score_matrix[j][i] = 1 -((dist_score[j] * 0.5) + ( euclid_score[j]* 0.5))  #(self.euclid_sim(det_data['feat'], self.trackers[j]['feat']))*0.0 +\r\n                    except:\r\n                        pass\r\n                        # print(j)\r\n            target_det.append(det_data)\r\n\r\n        # print('=====================================================================================')\r\n\r\n        if frame_cnt == 0:\r\n            final_targets = [state for id, state in self.trackers.items() if state['stat'] is True]\r\n            return final_targets\r\n\r\n        score_matrix[np.isnan(score_matrix)] = 1.0\r\n        # print(score_matrix)\r\n        row_ind, col_ind = linear_sum_assignment(score_matrix)  # hungarian.\r\n        # print(row_ind, col_ind)\r\n        hungarian_result = col_ind[:self.max_tracker]\r\n        # print(hungarian_result)\r\n        # id -> idx 로 저장해야됨.\r\n        # print(len(target_det))\r\n        for id, idx in enumerate(hungarian_result):  # id_update.\r\n            # print('업데이트 타겟. idx : {0}, id: {1}'.format(idx, self.trackers[id]['id']))\r\n            if idx < len(target_det):\r\n                if  score_matrix[idx][id] < 0.5:  # and score_matrix[idx][id] < 0.5  self.trackers[id]['frame'] >= frame_cnt-1\r\n                    self.tracker_provider(target_=target_det[idx],\r\n                                          t_id=self.trackers[id]['id'], update=True)\r\n                    target_det[idx]['id'] = self.trackers[id]['id']\r\n\r\n                if target_det[idx]['id'] == -1 and not self.occluded_tracker(target=target_det[idx]):# 타겟 아이디가 -1 일때.\r\n                    target_det[idx]['id'] = self.tracker_provider(target_det[idx])  # 트래커 생성\r\n\r\n        self.tracker_eliminator(frame_cnt)\r\n\r\n        final_targets = [state for id, state in self.trackers.items() if state['stat'] is True]\r\n\r\n        return final_targets\r\n\r\n                # print('idx :',idx,'id : ', target_frame[idx]['id'], ' -->  idx :', id,'id : ', target_frame[id]['id'],'\\n')\r\n\r\n        # final_targets.clear()\r\n        # for n, target in enumerate(target_det):\r\n        #     # print('최종 타겟들 추가하기.',len(target_frame), num_trackers)\r\n        #     # print(n, ' 타겟들. target_frames : {0}, id: {1}'.format(target['frame'],\r\n        #     #                                                                 target['id']))\r\n        #     if n >= num_trackers:\r\n        #         if target['id'] == -1 or target['id'] == None:\r\n        #             target['id'] = self.tracker_provider(target)  # 트래커 생성\r\n        #         if target['id'] != self.ghost_id:\r\n        #             # print(n, ' 추가된 디텍션들. final_target_frames : {0}, id: {1}'.format(target['frame'],\r\n        #             #                                                                 target['id']))\r\n        #             final_targets.append(target)\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/examples/tracker_demo.py b/examples/tracker_demo.py
--- a/examples/tracker_demo.py	(revision 18467b59330e6c172876c0d7f63080460e7ac24e)
+++ b/examples/tracker_demo.py	(date 1623293260587)
@@ -168,7 +168,7 @@
         # euclid_score = np.ones(shape=(len_trk,), dtype=np.float32)
         if(len_trk > 0):
             trackers = torch.cat(target_trk, dim=0)
-            ass_mat = self.simsiam.get_association_matrix(self.simsiam.backbone, trackers, target.unsqueeze(0), k=min(len_trk, 5))
+            ass_mat = self.simsiam.get_association_matrix(self.simsiam.get_backbone(), trackers, target.unsqueeze(0), k=min(len_trk, 5))
             print(ass_mat)
         # for j, trk in enumerate(target_trk):
         #     # print(target)
Index: simsiam_standalone.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import torch\r\nimport torch.nn.functional as F\r\nfrom models import SimSiam\r\n\r\n\r\n# trackers = torch.rand([10, 3, 224, 112]).cuda(non_blocking=True)  # RGB, 0~1\r\n# detections = torch.rand([8, 3, 224, 112]).cuda(non_blocking=True)\r\n#\r\n# ass_mat = get_association_matrix(model.backbone, trackers, detections, k=min(len(trackers), 5))\r\n\r\n\r\nclass simsiam_model():\r\n    def __init__(self):\r\n        self.model = SimSiam().cuda()\r\n        self.model.load_state_dict(torch.load('E:/_workspace/rcnnpose-pytorch-tracker/ckpt/simsiam2.pt'))\r\n        self.model.eval()\r\n\r\n    def backbone(self):\r\n        return self.model.backbone\r\n\r\n    def get_association_matrix(self, net, trackers, detections, k, t=0.1):\r\n        with torch.no_grad():\r\n            z_trackers = net(trackers)\r\n            z_trackers = F.normalize(z_trackers, dim=1)\r\n\r\n            z_detections = net(detections)\r\n            z_detections = F.normalize(z_detections, dim=1)\r\n\r\n            ass_mat = torch.mm(z_detections, z_trackers.t())\r\n\r\n            top_scores, top_indicies = ass_mat.topk(k=k, dim=-1)\r\n\r\n            top_scores = (top_scores / t).exp()\r\n\r\n            return {\r\n                'ass_mat': ass_mat, # ass_mat : 디텍션x트래커 매트릭스\r\n                'scores': top_scores, # scores : 디텍션xTopK트래커 스코어\r\n                'indicies': top_indicies # indicies : 디텍션xTopK트래커 인덱스\r\n            }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/simsiam_standalone.py b/simsiam_standalone.py
--- a/simsiam_standalone.py	(revision 18467b59330e6c172876c0d7f63080460e7ac24e)
+++ b/simsiam_standalone.py	(date 1623293223782)
@@ -15,7 +15,7 @@
         self.model.load_state_dict(torch.load('E:/_workspace/rcnnpose-pytorch-tracker/ckpt/simsiam2.pt'))
         self.model.eval()
 
-    def backbone(self):
+    def get_backbone(self):
         return self.model.backbone
 
     def get_association_matrix(self, net, trackers, detections, k, t=0.1):
